use strict;
use warnings;
### after: use lib qw(@RT_LIB_PATH@);
use lib qw(/opt/rt4/local/lib /opt/rt4/lib);

use RT::Test
    testing => 'RT::Extension::LDAPImport::MultiEmail',
    requires => ['RT::LDAPImport', 'RT::Extension::MergeUsers'],
    tests => undef;
eval { require Net::LDAP::Server::Test; 1; } or do {
    plan skip_all => 'Unable to test without Net::Server::LDAP::Test';
};
use Test::Warn;

for my $cfname (qw/SomeCF/) {
    my $cf = RT::CustomField->new(RT->SystemUser);
    my ($ok, $msg) = $cf->Create(
        Name        => $cfname,
        LookupType  => 'RT::User',
        Type        => 'FreeformSingle',
        Disabled    => 0,
    );
    ok $cf->Id, $msg;

    my $ocf = RT::ObjectCustomField->new(RT->SystemUser);
    ($ok, $msg) = $ocf->Create( CustomField => $cf->Id );
    ok $ocf->Id, $msg;
}

my $importer = RT::Extension::LDAPImport->new;
isa_ok($importer,'RT::LDAPImport');
isa_ok($importer,'RT::Extension::LDAPImport::MultiEmail');
$importer->screendebug(1) if ($ENV{TEST_VERBOSE});

my $ldap_port = 1024 + int rand(10000) + $$ % 1024;
ok( my $server = Net::LDAP::Server::Test->new( $ldap_port, auto_schema => 1 ),
    "spawned test LDAP server on port $ldap_port");
my $ldap = Net::LDAP->new("localhost:$ldap_port");
$ldap->bind();
$ldap->add("ou=People,dc=example,dc=com");

$ldap->add( "uid=testing,ou=People,dc=example,dc=com", attr => [
    objectclass => 'User',
    uid => 'testing',
    cn => 'Timmy Testing',
    mail => 'tim@example.com',
    alternateEmail => 'timmy@example.com',
    alternateEmail => 'testing@example.com',
    moreEmail => 'more@example.com',
    other => 'Some value',
] );

RT->Config->Set('LDAPHost',"ldap://localhost:$ldap_port");
RT->Config->Set('LDAPUser', undef);
RT->Config->Set('LDAPPassword', undef);
require RT::Extension::LDAPImport::MultiEmail;
RT->Config->Set('LDAPMapping', {
    Name                  => 'uid',
    EmailAddress          => 'mail',
    RealName              => 'cn',
    'UserCF.SomeCF'       => 'other',
});
RT->Config->Set('LDAPBase','ou=People,dc=example,dc=com');
RT->Config->Set('LDAPFilter','(objectClass=User)');
RT->Config->Set('LDAPSkipAutogeneratedGroup',1);
RT->Config->Set('LDAPMultiEmail', ['alternateEmail', 'moreEmail']);

ok($importer->import_users( import => 1 ));

user_is( 'testing',
         Name              => "testing",         "Name is right",
         RealName          => "Timmy Testing",   "RealName is right",
         EmailAddress      => 'tim@example.com', "Email is right",
         'CF.SomeCF'       => 'Some value',      "Set the CF",
         Merged            => ['timmy@example.com', 'testing@example.com', 'more@example.com'],
                                                 "Merged users check out",
     );
user_is( 'timmy@example.com',
         EmailAddress      => 'timmy@example.com', "Merged user has right email address",
         RealName          => 'Timmy Testing',     "Picked up properties of main user",
     );

# Ensure that this is idempotent
ok($importer->import_users( import => 1 ));
user_is( 'testing',
         Merged => ['timmy@example.com', 'testing@example.com', 'more@example.com'],
         "Still properly merged",
     );

# Removing an attribute un-merges the user
$ldap->modify( "uid=testing,ou=People,dc=example,dc=com",
               delete => {
                   alternateEmail => ['testing@example.com'],
               }
           );
ok($importer->import_users( import => 1 ));
user_is( 'testing',
         Merged => ['timmy@example.com', 'more@example.com'],
         "Removing alternate unmerges the user",
     );

# Changing the set of attributes un-merges the user
RT->Config->Set('LDAPMultiEmail', 'alternateEmail');
ok($importer->import_users( import => 1 ));
user_is( 'testing',
         Merged => ['timmy@example.com'],
         "No longer merged into other",
     );

# Test when alternate email addresses collide
$ldap->add( "uid=other,ou=People,dc=example,dc=com", attr => [
    objectclass => 'User',
    uid => 'other',
    cn => 'Other User',
    mail => 'other@example.com',
    alternateEmail => 'timmy@example.com',
] );
warning_like {
    ok($importer->import_users( import => 1 ));
} qr/already merged into tim\@example\.com/;
user_is( 'testing',
         Merged => ['timmy@example.com'], 'testing is still merged into timmy@example.com'
     );
user_is( 'other',
         Merged => [], 'other is not merged into timmy@example.com',
     );


sub user_is {
    my ($username, @props) = @_;
    local $Test::Builder::Level = $Test::Builder::Level + 1;
    my $user = RT::User->new( RT->SystemUser );
    $user->LoadOriginal( Name => $username );
    ok( $user->id, "Loaded user $username" );
    while (@props) {
        my ($name, $value, $msg) = splice @props, 0, 3;
        if ($name =~ /^CF\.(.*)/) {
            is( $user->FirstCustomFieldValue($1), $value, $msg );
        } elsif ($name eq "Merged") {
            my %want = map {+($_ => 1)} @{$value};
            my $merged = $user->GetMergedUsers;
            my @ids = @{$merged->Content};
            subtest $msg => sub {
                is(scalar(@ids), scalar(keys %want), "Got the right number of merged users: @ids");
                for my $id (@ids) {
                    my $other = RT::User->new( RT->SystemUser );
                    $other->LoadOriginal( id => $id );
                    is( $id, $other->Id, "Loaded other user $id" );
                    ok( $want{$other->EmailAddress} == 1, "Wanted to find ".$other->EmailAddress);
                }
            };
        } else {
            is( $user->$name, $value, $msg );
        }
    }
}

$ldap->unbind;
done_testing;
